
    [HarmonyPatch(typeof(HeroConversationBehavior), "AddHeroConversations")]
    public class HeroConvSafePatch
    {
        static void Prefix()
        {
            if (Campaign.Current == null || Kingdom.All == null || Campaign.Current.Models == null)
                return false; // Or skip logic

            try
            {
                var hero = Hero.OneToOneConversationHero;
                if (!IsPatchableHero(hero)) return;

                // Notables should at least be tied to their settlement's owner kingdom
                if (hero.IsNotable && hero.HomeSettlement != null)
                {
                    var fallbackFaction = hero.HomeSettlement.OwnerClan?.Kingdom;
                    if (hero.Clan == null && fallbackFaction != null)
                    {
                        // Create a dummy clan or inject into their settlement's kingdom
                        // but not always safe — better to just log
                        InformationManager.DisplayMessage(new InformationMessage(
                            $"[SafeWarLogPatch] Notable {hero.Name} has no clan. Skipping safe patch."));
                        return;
                    }
                }

                // Fallback for lords or broken nobles
                if (hero.Clan == null || hero.MapFaction == null)
                {
                    var fallback = Hero.MainHero.MapFaction
                    ?? MobileParty.MainParty?.MapFaction
                    ?? Settlement.CurrentSettlement?.OwnerClan?.Kingdom;

                    if (fallback != null)
                    {
                        if (hero.Clan != null && fallback is Kingdom kingdom)
                        {
                            ChangeKingdomAction.ApplyByJoinToKingdom(hero.Clan, kingdom, false);
                            InformationManager.DisplayMessage(new InformationMessage(
                                $"[SafeWarLogPatch] Patched {hero.Name}'s faction: → {fallback.Name}"));
                        }
                    }
                }

            }
            catch (System.Exception ex)
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[SafeWarLogPatch] Error during conversation safety: {ex.Message}"));
            }
        }

        private static bool IsPatchableHero(Hero hero)
        {
            if (hero == null || !hero.IsAlive)
                return false;

            if (hero.IsWanderer)
                return false;

            if (hero.IsBandit || hero.IsOutlaw)
                return false;

            if (hero.IsNotable)
                return false;

            if (hero.IsChild || hero.IsTemplate)
                return false;

            if (hero.CharacterObject?.Occupation == Occupation.Villager ||
                hero.CharacterObject?.Occupation == Occupation.Bandit)
                return false;

            // Nobles, vassals, companions (if clan-assigned) are patchable
            return true;
        }

    }

    [HarmonyPatch(typeof(CampaignInformationManager), "AddWarDeclaredLogEntry")]
    public class WarLogSafePatch
    {
        static bool Prefix(ref IFaction faction1, ref IFaction faction2, ref Hero declaringHero)
        {
            if (Campaign.Current == null || Kingdom.All == null || Campaign.Current.Models == null)
                return false; // Or skip logic

            bool replaced = false;

            if (declaringHero == null || declaringHero.IsDead)
                declaringHero = Hero.MainHero;

            if (faction1 == null)
            {
                faction1 = declaringHero?.MapFaction;
                replaced = true;
            }

            if (faction2 == null && faction1 is Kingdom declaringKingdom)
            {
                faction2 = Kingdom.All
                .Where(k =>
                k != declaringKingdom &&
                !k.IsEliminated &&
                !declaringKingdom.IsAtWarWith(k) &&
                k.Fiefs.Any()) // has territory
                .OrderByDescending(k => GetWeightedWarScore(declaringKingdom, k))
                .FirstOrDefault();

                replaced = true;
            }

            if (faction1 is Kingdom k1 && faction2 is Kingdom k2)
            {
                var decision = new DeclareWarDecision(k1, k2);
                k1.AddDecision(decision);

                InformationManager.DisplayMessage(new InformationMessage(
                    $"[SafeWarLogPatch] Recovered war declaration via vote: {faction1.Name} → {faction2.Name}"));
                return false;
            }

            if (faction1 == null || faction2 == null)
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    "[SafeWarLogPatch] Skipped war declaration: unable to infer valid factions."));
                return false;
            }

            if (replaced)
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[SafeWarLogPatch] Inferred war declaration: {faction1.Name} → {faction2.Name}"));
            }

            return true;
        }

        private static float GetWeightedWarScore(Kingdom source, Kingdom target)
        {
            try
            {
                float score = Campaign.Current.Models.KingdomDiplomacyModel.GetScoreOfDeclaringWarOnFaction(source, target);
                float proximity = GetBorderDistanceScore(source, target);
                float sizePenalty = target.Fiefs.Count < 3 ? -20f : 0f;
                return score + proximity + sizePenalty;
            }
            catch
            {
                return -1000f;
            }
        }

        private static float GetBorderDistanceScore(Kingdom a, Kingdom b)
        {
            var aCenters = a.Fiefs.Select(f => f.Settlement.Position2D).ToList();
            var bCenters = b.Fiefs.Select(f => f.Settlement.Position2D).ToList();

            if (!aCenters.Any() || !bCenters.Any())
                return -50f;

            float minDistance = aCenters.Min(aPos =>
            bCenters.Min(bPos => aPos.DistanceSquared(bPos)));

            // Invert: closer = higher score
            return 100f / (1f + minDistance);
        }
    }





     [HarmonyPatch(typeof(InformationManager), nameof(InformationManager.DisplayMessage))]
    public class MessageFilterPatch
    {
        static bool Prefix(InformationMessage message)
        {
            if (Campaign.Current == null || Kingdom.All == null || Campaign.Current.Models == null)
                return false; // Or skip logic

            if (message == null || string.IsNullOrEmpty(message.Text))
                return true;

            string text = message.Text.ToLowerInvariant();

            bool isRecruitLog = text.Contains("recruited");
            bool isGreen = message.Color.NearlyEquals(Colors.Green) || message.Color.NearlyEquals(Colors.LightGreen);

            if (isGreen && isRecruitLog)
            {
                // Example: "Derthert recruited Imperial Infantryman"
                string[] words = text.Split(' ');

                // Filter short messages: likely "Hero recruited Troop"
                if (words.Length >= 3 && words.Contains("recruited"))
                {
                    int index = Array.IndexOf(words, "recruited");
                    if (index == 1 || index == 2) // "X recruited Y", "X Y recruited Z"
                    {
                        return false; // Suppress
                    }
                }
            }

            return true;
        }
    }

    public static class ColorExtensions
    {
        public static bool NearlyEquals(this Color a, Color b, float tolerance = 0.05f)
        {
            return
            MathF.Abs(a.Red - b.Red) < tolerance &&
            MathF.Abs(a.Green - b.Green) < tolerance &&
            MathF.Abs(a.Blue - b.Blue) < tolerance;
        }
    }
